{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"colormap-tool","text":"<p>A Colormap Tool package to convert cmps between cv and mpl.</p> <ul> <li>Github repository: https://github.com/MeridianInnovation/colormap-tool/</li> <li>Documentation https://MeridianInnovation.github.io/colormap-tool/</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>This package can let users use cv's built-in colormap in matplotlib, or use matplotlib's colormap in cv.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Convert colormaps between matplotlib and OpenCV formats</li> <li>Access colormaps from matplotlib and OpenCVs through a common interface</li> <li>Convert between numpy arrays, matplotlib Colormap objects, and OpenCV constants</li> <li>Register external colormaps with matplotlib</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the project, run the following command:</p> <pre><code>python -m pip install colormap-tool\n</code></pre>"},{"location":"API/api_reference/","title":"API Reference","text":""},{"location":"API/api_reference/#colormap_tool","title":"<code>colormap_tool</code>","text":"<p>Colormap Tools - A library for working with colormaps across different visualization libraries.</p> <p>This package provides utilities for loading, converting, and using colormaps from various sources (matplotlib, OpenCV) in a consistent way. It allows using colormaps from one library in another, for example using a matplotlib colormap in OpenCV or vice versa.</p> <p>The package loads colormaps from pickle files that store them as numpy arrays with shape (256, 1, 3) and dtype uint8. These colormaps can then be converted to the appropriate format for each visualization library.</p> <p>Main components:</p> <ul> <li>_cmps.py: Loads and stores colormap data from pickle files, provides RGB format colormaps and resampling utilities</li> <li>_cv.py: Provides colormaps in OpenCV format (BGR)</li> <li>_mpl.py: Provides colormaps in Matplotlib format</li> </ul>"},{"location":"API/api_reference/#colormap_tool.apply_colormap_with_numpy","title":"<code>apply_colormap_with_numpy(src, cmp, dst=None)</code>","text":"<p>Apply a colormap to an image using numpy instead of OpenCV.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The image to apply the colormap to.</p> required <code>ndarray</code> <p>The colormap to apply. Should have shape (256, 1, 3) and dtype uint8.</p> required <code>ndarray</code> <p>The output array to store the result. If None, a new array will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The output array with the colormap applied.</p> Source code in <code>src/colormap_tool/_cv.py</code> <pre><code>def apply_colormap_with_numpy(src: np.ndarray, cmp: np.ndarray, dst: np.ndarray | None = None) -&gt; np.ndarray:\n    \"\"\"Apply a colormap to an image using numpy instead of OpenCV.\n\n    Parameters\n    ----------\n    src : numpy.ndarray\n        The image to apply the colormap to.\n    cmp : numpy.ndarray\n        The colormap to apply. Should have shape (256, 1, 3) and dtype uint8.\n    dst : numpy.ndarray, optional\n        The output array to store the result. If None, a new array will be created.\n\n    Returns\n    -------\n    numpy.ndarray\n        The output array with the colormap applied.\n\n    \"\"\"\n    if dst is None:\n        dst = np.zeros_like(src)\n    else:\n        if dst.shape != src.shape:\n            raise ValueError(\n                f\"The shape of the output array {dst.shape} does not match the shape of the input array {src.shape}.\",\n            )\n\n    if src.dtype != np.uint8:\n        raise ValueError(f\"The dtype of the input array {src.dtype} is not uint8.\")\n    if cmp.shape != (256, 1, 3):\n        raise ValueError(f\"The shape of the colormap array {cmp.shape} is not (256, 1, 3).\")\n    if cmp.dtype != np.uint8:\n        raise ValueError(f\"The dtype of the colormap array {cmp.dtype} is not uint8.\")\n\n    dst = cmp.copy().squeeze()\n    dst = dst[src]\n\n    return dst\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.apply_colormap_with_numpy(src)","title":"<code>src</code>","text":""},{"location":"API/api_reference/#colormap_tool.apply_colormap_with_numpy(cmp)","title":"<code>cmp</code>","text":""},{"location":"API/api_reference/#colormap_tool.apply_colormap_with_numpy(dst)","title":"<code>dst</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_colormaps","title":"<code>get_colormaps(name, namespace=None, n=None)</code>","text":"<p>Return a colormap as an RGB LUT array.</p> <p>Returns a (n, 3) uint8 array in RGB order, resampled to length n if specified. Useful for custom visualization, further conversion, or as a base for other formats.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Colormap name. If namespace is None, use \"namespace.name\" format.</p> required <code>str</code> <p>\"cv\" for OpenCV, \"mpl\" for Matplotlib.</p> <code>None</code> <code>int</code> <p>Number of LUT entries. If None, defaults to 256.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>(n, 3) uint8 RGB LUT.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the colormap or namespace is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lut = get_colormaps(\"mpl.viridis\", n=128)\n&gt;&gt;&gt; plt.imshow(data, cmap=colormap_tools.uint8_rgb_arr2mpl_cmp(lut))\n</code></pre> Source code in <code>src/colormap_tool/_cmps.py</code> <pre><code>def get_colormaps(name: str, namespace: str | None = None, n: int | None = None) -&gt; np.ndarray:\n    \"\"\"Return a colormap as an RGB LUT array.\n\n    Returns a (n, 3) uint8 array in RGB order, resampled to length n if specified.\n    Useful for custom visualization, further conversion, or as a base for other formats.\n\n    Parameters\n    ----------\n    name : str\n        Colormap name. If namespace is None, use \"namespace.name\" format.\n    namespace : str, optional\n        \"cv\" for OpenCV, \"mpl\" for Matplotlib.\n    n : int, optional\n        Number of LUT entries. If None, defaults to 256.\n\n    Returns\n    -------\n    np.ndarray\n        (n, 3) uint8 RGB LUT.\n\n    Raises\n    ------\n    ValueError\n        If the colormap or namespace is not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; lut = get_colormaps(\"mpl.viridis\", n=128)\n    &gt;&gt;&gt; plt.imshow(data, cmap=colormap_tools.uint8_rgb_arr2mpl_cmp(lut))\n\n    \"\"\"\n    if namespace is not None:\n        if \".\" in name:\n            raise ValueError(f\"Namespace {namespace} is provided, so name {name} should not include a dot.\")\n    else:\n        namespace, name = name.split(\".\")\n\n    namespace = namespace.lower()\n    name = name.lower()\n    if namespace not in CMPSPACE:\n        raise ValueError(f\"Namespace {namespace} is not recognized.\")\n    if name not in CMPSPACE[namespace]:\n        raise ValueError(f\"Colormap {name} is not found in namespace {namespace}.\")\n\n    # Get the original LUT\n    lut = CMPSPACE[namespace][name]\n\n    # Reshape to (256, 3)\n    lut = lut.reshape(-1, 3)\n\n    # Resample if requested\n    if n is not None and n != lut.shape[0]:\n        lut = resample_lut(lut, n)\n\n    return lut\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.get_colormaps(name)","title":"<code>name</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_colormaps(namespace)","title":"<code>namespace</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_colormaps(n)","title":"<code>n</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_cv_colormaps","title":"<code>get_cv_colormaps(name, namespace=None, return_arr=False)</code>","text":"<p>Return a colormap suitable for OpenCV's cv2.applyColorMap.</p> <ul> <li>If the colormap is an OpenCV built-in, returns the OpenCV integer constant (e.g., cv2.COLORMAP_JET).</li> <li>If the colormap is from Matplotlib or custom, returns a (256, 1, 3) uint8 LUT in BGR order,   which can be passed directly to cv2.applyColorMap.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Colormap name. If namespace is None, use \"namespace.name\" format (e.g., \"cv.jet\", \"mpl.viridis\").</p> required <code>str</code> <p>\"cv\" for OpenCV, \"mpl\" for Matplotlib. If provided, name should not include a dot.</p> <code>None</code> <code>bool</code> <p>If True, always return a LUT array (never an OpenCV constant).</p> <code>False</code> <p>Returns:</p> Type Description <code>int or ndarray</code> <p>OpenCV colormap constant or a (256, 1, 3) uint8 LUT in BGR order.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the colormap or namespace is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lut = get_cv_colormaps(\"mpl.viridis\")\n&gt;&gt;&gt; img_color = cv2.applyColorMap(gray_img, lut)\n&gt;&gt;&gt; lut2 = get_cv_colormaps(\"jet\", \"cv\")\n&gt;&gt;&gt; img_color2 = cv2.applyColorMap(gray_img, lut2)\n</code></pre> Source code in <code>src/colormap_tool/_cv.py</code> <pre><code>def get_cv_colormaps(name: str, namespace: str | None = None, return_arr: bool = False) -&gt; int | np.ndarray:\n    \"\"\"Return a colormap suitable for OpenCV's cv2.applyColorMap.\n\n    - If the colormap is an OpenCV built-in, returns the OpenCV integer constant (e.g., cv2.COLORMAP_JET).\n    - If the colormap is from Matplotlib or custom, returns a (256, 1, 3) uint8 LUT in BGR order,\n      which can be passed directly to cv2.applyColorMap.\n\n    Parameters\n    ----------\n    name : str\n        Colormap name. If namespace is None, use \"namespace.name\" format (e.g., \"cv.jet\", \"mpl.viridis\").\n    namespace : str, optional\n        \"cv\" for OpenCV, \"mpl\" for Matplotlib. If provided, name should not include a dot.\n    return_arr : bool, optional\n        If True, always return a LUT array (never an OpenCV constant).\n\n    Returns\n    -------\n    int or np.ndarray\n        OpenCV colormap constant or a (256, 1, 3) uint8 LUT in BGR order.\n\n    Raises\n    ------\n    ValueError\n        If the colormap or namespace is not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; lut = get_cv_colormaps(\"mpl.viridis\")\n    &gt;&gt;&gt; img_color = cv2.applyColorMap(gray_img, lut)\n    &gt;&gt;&gt; lut2 = get_cv_colormaps(\"jet\", \"cv\")\n    &gt;&gt;&gt; img_color2 = cv2.applyColorMap(gray_img, lut2)\n\n    \"\"\"\n    try:\n        import cv2\n    except ImportError:\n        cv2 = None\n    if namespace is not None:\n        if \".\" in name:\n            raise ValueError(f\"Namespace {namespace} is provided, so name {name} should not include a dot.\")\n    else:\n        namespace, name = name.split(\".\")\n\n    namespace = namespace.lower()\n    name = name.lower()\n    if namespace not in CMPSPACE:\n        raise ValueError(f\"Namespace {namespace} is not recognized.\")\n    if name not in CMPSPACE[namespace]:\n        raise ValueError(f\"Colormap {name} is not found in namespace {namespace}.\")\n\n    if namespace == \"cv\" and not return_arr and cv2 is not None:\n        return cv2.__dict__[f\"COLORMAP_{name.upper()}\"]\n    else:\n        rgb_arr = CMPSPACE[namespace][name]\n        bgr_arr = rgb_arr[:, :, ::-1]\n        return bgr_arr\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.get_cv_colormaps(name)","title":"<code>name</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_cv_colormaps(namespace)","title":"<code>namespace</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_cv_colormaps(return_arr)","title":"<code>return_arr</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_mpl_colormaps","title":"<code>get_mpl_colormaps(name, namespace=None)</code>","text":"<p>Get a colormap in Matplotlib format.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the colormap. If namespace is None, this should be in the format \"namespace.name\" (e.g., \"cv.VIRIDIS\", \"mpl.viridis\").</p> required <code>Optional[str]</code> <p>The namespace of the colormap (\"cv\", \"mpl\"). If provided, the name parameter should not include the namespace prefix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Colormap</code> <p>A Matplotlib Colormap object that can be used with matplotlib plotting functions. For matplotlib colormaps (namespace=\"mpl\"), returns the built-in colormap. For other colormaps, converts the numpy array to a Matplotlib ListedColormap.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the namespace is not recognized or the colormap name is not found in the namespace.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get a matplotlib built-in colormap\n&gt;&gt;&gt; cmap = get_mpl_colormaps(\"viridis\", \"mpl\")\n&gt;&gt;&gt; # Or equivalently\n&gt;&gt;&gt; cmap = get_mpl_colormaps(\"mpl.viridis\")\n&gt;&gt;&gt; plt.imshow(data, cmap=cmap)\n</code></pre> <pre><code>&gt;&gt;&gt; # Get an OpenCV colormap for use with matplotlib\n&gt;&gt;&gt; cmap = get_mpl_colormaps(\"VIRIDIS\", \"cv\")\n&gt;&gt;&gt; # Or equivalently\n&gt;&gt;&gt; cmap = get_mpl_colormaps(\"cv.VIRIDIS\")\n&gt;&gt;&gt; plt.imshow(data, cmap=cmap)\n</code></pre> Source code in <code>src/colormap_tool/_mpl.py</code> <pre><code>def get_mpl_colormaps(name: str, namespace: str | None = None) -&gt; Colormap:\n    \"\"\"Get a colormap in Matplotlib format.\n\n    Parameters\n    ----------\n    name : str\n        The name of the colormap. If namespace is None, this should be in the format\n        \"namespace.name\" (e.g., \"cv.VIRIDIS\", \"mpl.viridis\").\n    namespace : Optional[str], optional\n        The namespace of the colormap (\"cv\", \"mpl\"). If provided, the name\n        parameter should not include the namespace prefix.\n\n    Returns\n    -------\n    matplotlib.colors.Colormap\n        A Matplotlib Colormap object that can be used with matplotlib plotting functions.\n        For matplotlib colormaps (namespace=\"mpl\"), returns the built-in colormap.\n        For other colormaps, converts the numpy array to a Matplotlib ListedColormap.\n\n    Raises\n    ------\n    AssertionError\n        If the namespace is not recognized or the colormap name is not found in the namespace.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Get a matplotlib built-in colormap\n    &gt;&gt;&gt; cmap = get_mpl_colormaps(\"viridis\", \"mpl\")\n    &gt;&gt;&gt; # Or equivalently\n    &gt;&gt;&gt; cmap = get_mpl_colormaps(\"mpl.viridis\")\n    &gt;&gt;&gt; plt.imshow(data, cmap=cmap)\n\n    &gt;&gt;&gt; # Get an OpenCV colormap for use with matplotlib\n    &gt;&gt;&gt; cmap = get_mpl_colormaps(\"VIRIDIS\", \"cv\")\n    &gt;&gt;&gt; # Or equivalently\n    &gt;&gt;&gt; cmap = get_mpl_colormaps(\"cv.VIRIDIS\")\n    &gt;&gt;&gt; plt.imshow(data, cmap=cmap)\n\n    \"\"\"\n    try:\n        import matplotlib as mpl\n    except ImportError as err:\n        raise ImportError(\"Missing optional dependency: matplotlib\", name=\"matplotlib\") from err\n    if namespace is not None:\n        if \".\" in name:\n            raise ValueError(f\"Namespace {namespace} is provided, so name {name} should not include a dot.\")\n    else:\n        namespace, name = name.split(\".\")\n\n    namespace = namespace.lower()\n    name = name.lower()\n    if namespace not in CMPSPACE:\n        raise ValueError(f\"Namespace {namespace} is not recognized.\")\n    if name not in CMPSPACE[namespace]:\n        raise ValueError(f\"Colormap {name} is not found in namespace {namespace}.\")\n\n    if namespace == \"mpl\":\n        return mpl.colormaps[name]\n    else:\n        if name not in _cached_colormaps[namespace]:\n            _cached_colormaps[namespace][name] = uint8_rgb_arr2mpl_cmp(\n                CMPSPACE[namespace][name],\n                f\"{namespace}.{name}\",\n                alpha=1.0,\n                mode=\"listed\",\n            )\n        return _cached_colormaps[namespace][name]\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.get_mpl_colormaps(name)","title":"<code>name</code>","text":""},{"location":"API/api_reference/#colormap_tool.get_mpl_colormaps(namespace)","title":"<code>namespace</code>","text":""},{"location":"API/api_reference/#colormap_tool.register_all_cmps2mpl","title":"<code>register_all_cmps2mpl()</code>","text":"<p>Register all available colormaps with the matplotlib.colormaps registry.</p> <p>This function iterates through all namespaces and colormap names in CMPSPACE and registers each colormap with matplotlib. After calling this function, all colormaps can be accessed directly through matplotlib.colormaps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; register_all_cmps2mpl()\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.imshow(data, cmap=\"cv.VIRIDIS\")\n</code></pre> Source code in <code>src/colormap_tool/_mpl.py</code> <pre><code>def register_all_cmps2mpl() -&gt; None:\n    \"\"\"Register all available colormaps with the matplotlib.colormaps registry.\n\n    This function iterates through all namespaces and colormap names in CMPSPACE\n    and registers each colormap with matplotlib. After calling this function,\n    all colormaps can be accessed directly through matplotlib.colormaps.\n\n    Examples\n    --------\n    &gt;&gt;&gt; register_all_cmps2mpl()\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; plt.imshow(data, cmap=\"cv.VIRIDIS\")\n\n    \"\"\"\n    try:\n        import matplotlib as mpl\n    except ImportError as err:\n        raise ImportError(\"Missing optional dependency: matplotlib\", name=\"matplotlib\") from err\n    global _is_registered\n    if _is_registered:\n        return\n    for namespace in CMPSPACE:\n        if namespace == \"mpl\":\n            continue\n        for name in CMPSPACE[namespace]:\n            cmp = get_mpl_colormaps(name, namespace)\n            mpl.colormaps.register(cmp)\n    _is_registered = True\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.resample_lut","title":"<code>resample_lut(lut, n)</code>","text":"<p>Resample a LUT to a new length.</p> <p>Accepts (m, 3) or (m, 1, 3) uint8 arrays. Returns the same format with length n.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Input LUT, shape (m, 3) or (m, 1, 3), dtype uint8.</p> required <code>int</code> <p>Target length.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Resampled LUT, same format as input, length n.</p> <p>Raises:</p> Type Description <code>(TypeError, ValueError)</code> <p>If input is not a valid LUT.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lut = np.array([[0, 0, 0], [255, 255, 255]], dtype=np.uint8)\n&gt;&gt;&gt; resample_lut(lut, 5).shape\n(5, 3)\n</code></pre> Source code in <code>src/colormap_tool/_cmps.py</code> <pre><code>def resample_lut(lut: np.ndarray, n: int) -&gt; np.ndarray:\n    \"\"\"Resample a LUT to a new length.\n\n    Accepts (m, 3) or (m, 1, 3) uint8 arrays. Returns the same format with length n.\n\n    Parameters\n    ----------\n    lut : np.ndarray\n        Input LUT, shape (m, 3) or (m, 1, 3), dtype uint8.\n    n : int\n        Target length.\n\n    Returns\n    -------\n    np.ndarray\n        Resampled LUT, same format as input, length n.\n\n    Raises\n    ------\n    TypeError, ValueError\n        If input is not a valid LUT.\n\n    Examples\n    --------\n    &gt;&gt;&gt; lut = np.array([[0, 0, 0], [255, 255, 255]], dtype=np.uint8)\n    &gt;&gt;&gt; resample_lut(lut, 5).shape\n    (5, 3)\n\n    \"\"\"\n    msg = \"The shape of the lut must be (n, 3) or (n, 1, 3).\"\n\n    if lut.ndim == 2:\n        if lut.shape[1] != 3:\n            raise ValueError(msg)\n        lut2d = lut\n        out_shape = (n, 3)\n    elif lut.ndim == 3:\n        if lut.shape[1] != 1 or lut.shape[2] != 3:\n            raise ValueError(msg)\n        lut2d = lut.reshape(-1, 3)\n        out_shape = (n, 1, 3)\n    else:\n        raise ValueError(msg)\n\n    m = lut2d.shape[0]\n    if n == m:\n        return lut.copy() if lut.shape[0] == n else lut2d.reshape(out_shape)\n\n    x_old = np.linspace(0, 1, m)\n    x_new = np.linspace(0, 1, n)\n    resampled = np.empty((n, 3), dtype=np.float32)\n    for c in range(3):\n        resampled[:, c] = np.interp(x_new, x_old, lut2d[:, c])\n    resampled = np.clip(resampled, 0, 255).astype(np.uint8)\n    return resampled.reshape(out_shape)\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.resample_lut(lut)","title":"<code>lut</code>","text":""},{"location":"API/api_reference/#colormap_tool.resample_lut(n)","title":"<code>n</code>","text":""},{"location":"API/api_reference/#colormap_tool.uint8_rgb_arr2mpl_cmp","title":"<code>uint8_rgb_arr2mpl_cmp(arr, name, alpha=1.0, mode='listed')</code>","text":"<p>Convert a uint8 RGB array to a Matplotlib Colormap object.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>A numpy array of RGB values with shape (N, 3) or (N, 1, 3) and dtype uint8. Values should be in the range [0, 255].</p> required <code>str</code> <p>The name to give to the colormap.</p> required <code>float</code> <p>The alpha (opacity) value for the colormap, by default 1.0 (fully opaque).</p> <code>1.0</code> <code>('listed', 'linear')</code> <p>The type of colormap to create: - \"listed\": Creates a ListedColormap (discrete colors) - \"linear\": Creates a LinearSegmentedColormap (interpolated colors) Default is \"listed\".</p> <code>\"listed\"</code> <p>Returns:</p> Type Description <code>Colormap</code> <p>A Matplotlib Colormap object (either ListedColormap or LinearSegmentedColormap depending on the mode parameter).</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the input array has an invalid shape or dtype.</p> <code>ValueError</code> <p>If the mode parameter is not \"listed\" or \"linear\".</p> Notes <p>The function converts the uint8 values [0-255] to float values [0-1] required by Matplotlib.</p> Source code in <code>src/colormap_tool/_mpl.py</code> <pre><code>def uint8_rgb_arr2mpl_cmp(\n    arr: np.ndarray,\n    name: str,\n    alpha: float = 1.0,\n    mode: Literal[\"listed\", \"linear\"] = \"listed\",\n) -&gt; Colormap:\n    \"\"\"Convert a uint8 RGB array to a Matplotlib Colormap object.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        A numpy array of RGB values with shape (N, 3) or (N, 1, 3) and dtype uint8.\n        Values should be in the range [0, 255].\n    name : str\n        The name to give to the colormap.\n    alpha : float, optional\n        The alpha (opacity) value for the colormap, by default 1.0 (fully opaque).\n    mode : {\"listed\", \"linear\"}, optional\n        The type of colormap to create:\n        - \"listed\": Creates a ListedColormap (discrete colors)\n        - \"linear\": Creates a LinearSegmentedColormap (interpolated colors)\n        Default is \"listed\".\n\n    Returns\n    -------\n    matplotlib.colors.Colormap\n        A Matplotlib Colormap object (either ListedColormap or LinearSegmentedColormap\n        depending on the mode parameter).\n\n    Raises\n    ------\n    AssertionError\n        If the input array has an invalid shape or dtype.\n    ValueError\n        If the mode parameter is not \"listed\" or \"linear\".\n\n    Notes\n    -----\n    The function converts the uint8 values [0-255] to float values [0-1] required by Matplotlib.\n\n    \"\"\"\n    try:\n        from matplotlib.colors import LinearSegmentedColormap, ListedColormap\n    except ImportError as err:\n        raise ImportError(\"Missing optional dependency: matplotlib\", name=\"matplotlib\") from err\n    if arr.ndim == 2 and arr.shape[1] != 3:\n        raise ValueError(f\"The shape of the input array {arr.shape} is not (N, 3).\")\n    if arr.ndim == 3:\n        if arr.shape[1] != 1:\n            raise ValueError(f\"The shape of the input array {arr.shape} is not (N, 1, 3).\")\n        if arr.shape[2] != 3:\n            raise ValueError(f\"The shape of the input array {arr.shape} is not (N, 1, 3).\")\n        arr = arr.squeeze(1)\n\n    if arr.dtype != np.uint8:\n        raise ValueError(f\"The dtype of the input array {arr.dtype} is not uint8.\")\n\n    # convert [0-255] uint8 to [0-1] float\n    arr = arr.astype(np.float64) / 255.0\n\n    alpha = np.full((arr.shape[0], 1), alpha)\n\n    arr = np.concatenate((arr, alpha), axis=1)\n\n    if mode == \"listed\":\n        return ListedColormap(arr, name=name)\n    elif mode == \"linear\":\n        return LinearSegmentedColormap.from_list(name, arr)\n    else:\n        raise ValueError(\"mode must be 'listed' or 'linear'\")\n</code></pre>"},{"location":"API/api_reference/#colormap_tool.uint8_rgb_arr2mpl_cmp(arr)","title":"<code>arr</code>","text":""},{"location":"API/api_reference/#colormap_tool.uint8_rgb_arr2mpl_cmp(name)","title":"<code>name</code>","text":""},{"location":"API/api_reference/#colormap_tool.uint8_rgb_arr2mpl_cmp(alpha)","title":"<code>alpha</code>","text":""},{"location":"API/api_reference/#colormap_tool.uint8_rgb_arr2mpl_cmp(mode)","title":"<code>mode</code>","text":""},{"location":"home/changelog/","title":"Changelog","text":""},{"location":"home/changelog/#v100-2025-06-16","title":"v1.0.0 (2025-06-16)","text":""},{"location":"home/changelog/#feat","title":"Feat","text":"<ul> <li>Add <code>get_colormaps</code> and <code>resample_lut</code></li> <li>Add support to py3.9</li> </ul>"},{"location":"home/changelog/#refactor","title":"Refactor","text":"<ul> <li>Update linting settings and fix some format issue.</li> </ul>"},{"location":"home/changelog/#v020-2025-05-12","title":"v0.2.0 (2025-05-12)","text":""},{"location":"home/changelog/#feat_1","title":"Feat","text":"<ul> <li>Implement the basic function of colormap_tool</li> <li>Add scripts to extract and save various colormaps from OpenCV and Matplotlib</li> </ul>"},{"location":"home/license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Meridian Innovation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"home/usage/","title":"Usage","text":""},{"location":"home/usage/#1-basic-import","title":"1. Basic Import","text":"<pre><code>import cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport colormap_tool\n</code></pre>"},{"location":"home/usage/#2-core-recipes","title":"2. Core Recipes","text":"<p>This library provides simple, one-line solutions for common colormap conversion tasks.</p>"},{"location":"home/usage/#recipe-1-use-a-matplotlib-colormap-in-opencv","title":"Recipe 1: Use a Matplotlib Colormap in OpenCV","text":"<p>To apply a Matplotlib colormap (e.g., <code>viridis</code>) to an image using <code>cv2.applyColorMap</code>, use <code>get_cv_colormaps</code>.</p> <p>This function automatically handles the conversion to the BGR format required by OpenCV.</p> <pre><code># Get the 'viridis' colormap in a format suitable for OpenCV\nlut = colormap_tool.get_cv_colormaps(\"mpl.viridis\")\n\n# Apply it to a grayscale image\ngray_img = np.random.randint(0, 255, (100, 100), dtype=np.uint8)\ncolored_img = cv2.applyColorMap(gray_img, lut)\n\n# Display the result\ncv2.imshow(\"Matplotlib's Viridis in OpenCV\", colored_img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"home/usage/#recipe-2-use-an-opencv-colormap-in-matplotlib","title":"Recipe 2: Use an OpenCV Colormap in Matplotlib","text":"<p>To use an OpenCV colormap (e.g., <code>jet</code>) in a Matplotlib plot, use <code>get_mpl_colormaps</code>.</p> <p>This function returns a <code>matplotlib.colors.Colormap</code> object that <code>matplotlib</code> understands.</p> <pre><code># Get the OpenCV 'jet' colormap as a Matplotlib Colormap object\ncmap = colormap_tool.get_mpl_colormaps(\"cv.jet\")\n\n# Use it in a plot\ndata = np.random.rand(20, 20)\nplt.imshow(data, cmap=cmap)\nplt.title(\"OpenCV's Jet in Matplotlib\")\nplt.colorbar()\nplt.show()\n</code></pre>"},{"location":"home/usage/#recipe-3-get-raw-colormap-data-rgb","title":"Recipe 3: Get Raw Colormap Data (RGB)","text":"<p>If you need the raw RGB color data for a colormap, use <code>get_colormaps</code>. This is useful for custom processing, analysis, or creating custom visualizations.</p> <p>You can also specify the number of entries (<code>n</code>) to resample the colormap.</p> <pre><code># Get the 'viridis' colormap as a 256-entry RGB array\nrgb_lut = colormap_tool.get_colormaps(\"mpl.viridis\", n=256)\n\n# rgb_lut is a (256, 3) numpy array with dtype=uint8\nprint(rgb_lut.shape)\nprint(rgb_lut.dtype)\n</code></pre>"},{"location":"home/usage/#3-advanced-usage","title":"3. Advanced Usage","text":""},{"location":"home/usage/#registering-all-colormaps-with-matplotlib","title":"Registering All Colormaps with Matplotlib","text":"<p>For maximum convenience, you can register all available colormaps with Matplotlib at the start of your script. This allows you to use them by name in any Matplotlib function.</p> <pre><code># Register all colormaps\ncolormap_tool.register_all_cmps2mpl()\n\n# Now, you can use OpenCV colormaps directly by name\ndata = np.random.rand(20, 20)\nplt.imshow(data, cmap=\"cv.jet\")\nplt.title(\"Using a Registered OpenCV Colormap\")\nplt.show()\n</code></pre>"},{"location":"home/usage/#custom-lut-resampling","title":"Custom LUT Resampling","text":"<p>The <code>resample_lut</code> function can resize any custom LUT to a desired length while preserving its format.</p> <pre><code># Create a simple 2-color LUT (black to white)\nmy_lut = np.array([[0, 0, 0], [255, 255, 255]], dtype=np.uint8)\n\n# Resample it to 10 entries\nresampled_lut = colormap_tool.resample_lut(my_lut, 10)\nprint(resampled_lut.shape)  # Output: (10, 3)\n</code></pre>"},{"location":"home/usage/#converting-a-custom-rgb-array-to-a-matplotlib-colormap","title":"Converting a Custom RGB Array to a Matplotlib Colormap","text":"<p>If you have your own colormap data as an RGB array, you can convert it into a Matplotlib <code>Colormap</code> object.</p> <pre><code># Create a custom gradient from blue to yellow\ncustom_rgb = np.zeros((256, 3), dtype=np.uint8)\ncustom_rgb[:, 0] = np.linspace(0, 255, 256)      # R\ncustom_rgb[:, 1] = np.linspace(0, 255, 256)      # G\ncustom_rgb[:, 2] = np.linspace(255, 0, 256)      # B\n\n# Convert it to a Matplotlib Colormap object\ncustom_cmap = colormap_tool.uint8_rgb_arr2mpl_cmp(custom_rgb, name=\"blue_yellow\")\n\n# Use it in a plot\nplt.imshow(data, cmap=custom_cmap)\nplt.title(\"Custom Blue-Yellow Colormap\")\nplt.show()\n</code></pre> <p>For more details, please refer to API Reference.</p>"}]}